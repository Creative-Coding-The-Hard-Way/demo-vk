<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A trait for anything that can read a variable number of potentially un-aligned values from an input stream"><title>BitRead in bitstream_io::read - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bitstream_io" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.1 (ed61e7d7e 2025-11-07)" data-channel="1.91.1" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">BitRead</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../bitstream_io/index.html">bitstream_<wbr>io</a><span class="version">4.9.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">BitRead</a></h2><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.byte_align" title="byte_align">byte_align</a></li><li><a href="#tymethod.byte_aligned" title="byte_aligned">byte_aligned</a></li><li><a href="#tymethod.read_as_to" title="read_as_to">read_as_to</a></li><li><a href="#tymethod.read_signed_counted" title="read_signed_counted">read_signed_counted</a></li><li><a href="#tymethod.read_to" title="read_to">read_to</a></li><li><a href="#tymethod.read_unsigned_counted" title="read_unsigned_counted">read_unsigned_counted</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.by_ref" title="by_ref">by_ref</a></li><li><a href="#method.parse" title="parse">parse</a></li><li><a href="#method.parse_using" title="parse_using">parse_using</a></li><li><a href="#method.parse_with" title="parse_with">parse_with</a></li><li><a href="#method.read" title="read">read</a></li><li><a href="#method.read_bit" title="read_bit">read_bit</a></li><li><a href="#method.read_bytes" title="read_bytes">read_bytes</a></li><li><a href="#method.read_checked" title="read_checked">read_checked</a></li><li><a href="#method.read_const" title="read_const">read_const</a></li><li><a href="#method.read_count" title="read_count">read_count</a></li><li><a href="#method.read_counted" title="read_counted">read_counted</a></li><li><a href="#method.read_huffman" title="read_huffman">read_huffman</a></li><li><a href="#method.read_signed" title="read_signed">read_signed</a></li><li><a href="#method.read_signed_var" title="read_signed_var">read_signed_var</a></li><li><a href="#method.read_signed_vbr" title="read_signed_vbr">read_signed_vbr</a></li><li><a href="#method.read_to_bytes" title="read_to_bytes">read_to_bytes</a></li><li><a href="#method.read_to_vec" title="read_to_vec">read_to_vec</a></li><li><a href="#method.read_unary" title="read_unary">read_unary</a></li><li><a href="#method.read_unsigned" title="read_unsigned">read_unsigned</a></li><li><a href="#method.read_unsigned_var" title="read_unsigned_var">read_unsigned_var</a></li><li><a href="#method.read_unsigned_vbr" title="read_unsigned_vbr">read_unsigned_vbr</a></li><li><a href="#method.read_var" title="read_var">read_var</a></li><li><a href="#method.read_vbr" title="read_vbr">read_vbr</a></li><li><a href="#method.skip" title="skip">skip</a></li></ul><h3><a href="#foreign-impls">Implementations on Foreign Types</a></h3><ul class="block"><li><a href="#impl-BitRead-for-%26mut+R" title="&#38;mut R">&#38;mut R</a></li></ul><h3><a href="#dyn-compatibility">Dyn Compatibility</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In bitstream_<wbr>io::<wbr>read</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">bitstream_io</a>::<wbr><a href="index.html">read</a></div><h1>Trait <span class="trait">BitRead</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/bitstream_io/read.rs.html#58-1041">Source</a> </span></div><pre class="rust item-decl"><code>pub trait BitRead {
<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 30 methods</span></summary>    // Required methods
    fn <a href="#tymethod.read_unsigned_counted" class="fn">read_unsigned_counted</a>&lt;const MAX: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, U&gt;(
        &amp;mut self,
        bits: <a class="struct" href="../struct.BitCount.html" title="struct bitstream_io::BitCount">BitCount</a>&lt;MAX&gt;,
    ) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;U&gt;
       <span class="where">where U: <a class="trait" href="../trait.UnsignedInteger.html" title="trait bitstream_io::UnsignedInteger">UnsignedInteger</a></span>;
<span class="item-spacer"></span>    fn <a href="#tymethod.read_signed_counted" class="fn">read_signed_counted</a>&lt;const MAX: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, S&gt;(
        &amp;mut self,
        bits: impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;<a class="struct" href="../struct.SignedBitCount.html" title="struct bitstream_io::SignedBitCount">SignedBitCount</a>&lt;MAX&gt;&gt;,
    ) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;S&gt;
       <span class="where">where S: <a class="trait" href="../trait.SignedInteger.html" title="trait bitstream_io::SignedInteger">SignedInteger</a></span>;
<span class="item-spacer"></span>    fn <a href="#tymethod.read_to" class="fn">read_to</a>&lt;V&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;V&gt;
       <span class="where">where V: <a class="trait" href="../trait.Primitive.html" title="trait bitstream_io::Primitive">Primitive</a></span>;
<span class="item-spacer"></span>    fn <a href="#tymethod.read_as_to" class="fn">read_as_to</a>&lt;F, V&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;V&gt;
       <span class="where">where F: <a class="trait" href="../trait.Endianness.html" title="trait bitstream_io::Endianness">Endianness</a>,
             V: <a class="trait" href="../trait.Primitive.html" title="trait bitstream_io::Primitive">Primitive</a></span>;
<span class="item-spacer"></span>    fn <a href="#tymethod.byte_aligned" class="fn">byte_aligned</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.byte_align" class="fn">byte_align</a>(&amp;mut self);

    // Provided methods
    fn <a href="#method.read_bit" class="fn">read_bit</a>(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.bool.html">bool</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read" class="fn">read</a>&lt;const BITS: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, I&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;I&gt;
       <span class="where">where I: <a class="trait" href="../trait.Integer.html" title="trait bitstream_io::Integer">Integer</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_var" class="fn">read_var</a>&lt;I&gt;(&amp;mut self, bits: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;I&gt;
       <span class="where">where I: <a class="trait" href="../trait.Integer.html" title="trait bitstream_io::Integer">Integer</a> + <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_count" class="fn">read_count</a>&lt;const MAX: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../struct.BitCount.html" title="struct bitstream_io::BitCount">BitCount</a>&lt;MAX&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_counted" class="fn">read_counted</a>&lt;const MAX: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, I&gt;(
        &amp;mut self,
        bits: <a class="struct" href="../struct.BitCount.html" title="struct bitstream_io::BitCount">BitCount</a>&lt;MAX&gt;,
    ) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;I&gt;
       <span class="where">where I: <a class="trait" href="../trait.Integer.html" title="trait bitstream_io::Integer">Integer</a> + <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_unsigned" class="fn">read_unsigned</a>&lt;const BITS: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, U&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;U&gt;
       <span class="where">where U: <a class="trait" href="../trait.UnsignedInteger.html" title="trait bitstream_io::UnsignedInteger">UnsignedInteger</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_unsigned_var" class="fn">read_unsigned_var</a>&lt;U&gt;(&amp;mut self, bits: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;U&gt;
       <span class="where">where U: <a class="trait" href="../trait.UnsignedInteger.html" title="trait bitstream_io::UnsignedInteger">UnsignedInteger</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_signed" class="fn">read_signed</a>&lt;const BITS: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, S&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;S&gt;
       <span class="where">where S: <a class="trait" href="../trait.SignedInteger.html" title="trait bitstream_io::SignedInteger">SignedInteger</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_signed_var" class="fn">read_signed_var</a>&lt;S&gt;(&amp;mut self, bits: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;S&gt;
       <span class="where">where S: <a class="trait" href="../trait.SignedInteger.html" title="trait bitstream_io::SignedInteger">SignedInteger</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_const" class="fn">read_const</a>&lt;const BITS: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, const VALUE: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, E&gt;(
        &amp;mut self,
        err: E,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, E&gt;
       <span class="where">where E: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.1/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.skip" class="fn">skip</a>(&amp;mut self, bits: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_bytes" class="fn">read_bytes</a>(&amp;mut self, buf: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>]) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_to_bytes" class="fn">read_to_bytes</a>&lt;const SIZE: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.usize.html">usize</a>&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.array.html">SIZE</a>]&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_to_vec" class="fn">read_to_vec</a>(&amp;mut self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.usize.html">usize</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_unary" class="fn">read_unary</a>&lt;const STOP_BIT: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_checked" class="fn">read_checked</a>&lt;C&gt;(&amp;mut self, count: C::<a class="associatedtype" href="../trait.CheckablePrimitive.html#associatedtype.CountType" title="type bitstream_io::CheckablePrimitive::CountType">CountType</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;C&gt;
       <span class="where">where C: <a class="trait" href="../trait.CheckablePrimitive.html" title="trait bitstream_io::CheckablePrimitive">CheckablePrimitive</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.parse" class="fn">parse</a>&lt;F: <a class="trait" href="trait.FromBitStream.html" title="trait bitstream_io::read::FromBitStream">FromBitStream</a>&gt;(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, F::<a class="associatedtype" href="trait.FromBitStream.html#associatedtype.Error" title="type bitstream_io::read::FromBitStream::Error">Error</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.parse_with" class="fn">parse_with</a>&lt;'a, F: <a class="trait" href="trait.FromBitStreamWith.html" title="trait bitstream_io::read::FromBitStreamWith">FromBitStreamWith</a>&lt;'a&gt;&gt;(
        &amp;mut self,
        context: &amp;F::<a class="associatedtype" href="trait.FromBitStreamWith.html#associatedtype.Context" title="type bitstream_io::read::FromBitStreamWith::Context">Context</a>,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, F::<a class="associatedtype" href="trait.FromBitStreamWith.html#associatedtype.Error" title="type bitstream_io::read::FromBitStreamWith::Error">Error</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.parse_using" class="fn">parse_using</a>&lt;F: <a class="trait" href="trait.FromBitStreamUsing.html" title="trait bitstream_io::read::FromBitStreamUsing">FromBitStreamUsing</a>&gt;(
        &amp;mut self,
        context: F::<a class="associatedtype" href="trait.FromBitStreamUsing.html#associatedtype.Context" title="type bitstream_io::read::FromBitStreamUsing::Context">Context</a>,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, F::<a class="associatedtype" href="trait.FromBitStreamUsing.html#associatedtype.Error" title="type bitstream_io::read::FromBitStreamUsing::Error">Error</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_huffman" class="fn">read_huffman</a>&lt;T&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;T::<a class="associatedtype" href="../huffman/trait.FromBits.html#associatedtype.Symbol" title="type bitstream_io::huffman::FromBits::Symbol">Symbol</a>&gt;
       <span class="where">where T: <a class="trait" href="../huffman/trait.FromBits.html" title="trait bitstream_io::huffman::FromBits">FromBits</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_unsigned_vbr" class="fn">read_unsigned_vbr</a>&lt;const FIELD_SIZE: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, U: <a class="trait" href="../trait.UnsignedInteger.html" title="trait bitstream_io::UnsignedInteger">UnsignedInteger</a>&gt;(
        &amp;mut self,
    ) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;U&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_signed_vbr" class="fn">read_signed_vbr</a>&lt;const FIELD_SIZE: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, I: <a class="trait" href="../trait.SignedInteger.html" title="trait bitstream_io::SignedInteger">SignedInteger</a>&gt;(
        &amp;mut self,
    ) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;I&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_vbr" class="fn">read_vbr</a>&lt;const FIELD_SIZE: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, I: <a class="trait" href="../trait.VBRInteger.html" title="trait bitstream_io::VBRInteger">VBRInteger</a>&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;I&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.by_ref" class="fn">by_ref</a>(&amp;mut self) -&gt; &amp;mut Self { ... }
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A trait for anything that can read a variable number of
potentially un-aligned values from an input stream</p>
</div></details><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.read_unsigned_counted" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#388-390">Source</a><h4 class="code-header">fn <a href="#tymethod.read_unsigned_counted" class="fn">read_unsigned_counted</a>&lt;const MAX: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, U&gt;(
    &amp;mut self,
    bits: <a class="struct" href="../struct.BitCount.html" title="struct bitstream_io::BitCount">BitCount</a>&lt;MAX&gt;,
) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;U&gt;<div class="where">where
    U: <a class="trait" href="../trait.UnsignedInteger.html" title="trait bitstream_io::UnsignedInteger">UnsignedInteger</a>,</div></h4></section></summary><div class="docblock"><p>Reads an unsigned value from the stream with
the given number of bits.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.
Also returns an error if the output type is too small
to hold the requested number of bits.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian, BitCount};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1111_0000</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="comment">// reading 4 bits with a maximum of 4 will fit into a u8
// so no runtime check needed
</span><span class="macro">assert_eq!</span>(r.read_unsigned_counted::&lt;<span class="number">4</span>, u8&gt;(BitCount::new::&lt;<span class="number">4</span>&gt;()).unwrap(), <span class="number">0b1111</span>);
<span class="comment">// reading 4 bits with a maximum of 64 might not fit into a u8
// so we need to verify this at runtime
</span><span class="macro">assert_eq!</span>(r.read_unsigned_counted::&lt;<span class="number">64</span>, u8&gt;(BitCount::new::&lt;<span class="number">4</span>&gt;()).unwrap(), <span class="number">0b0000</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="tymethod.read_signed_counted" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#508-513">Source</a><h4 class="code-header">fn <a href="#tymethod.read_signed_counted" class="fn">read_signed_counted</a>&lt;const MAX: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, S&gt;(
    &amp;mut self,
    bits: impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;<a class="struct" href="../struct.SignedBitCount.html" title="struct bitstream_io::SignedBitCount">SignedBitCount</a>&lt;MAX&gt;&gt;,
) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;S&gt;<div class="where">where
    S: <a class="trait" href="../trait.SignedInteger.html" title="trait bitstream_io::SignedInteger">SignedInteger</a>,</div></h4></section></summary><div class="docblock"><p>Reads a twos-complement signed value from the stream with
the given number of bits.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.
Returns an error if the number of bits is 0,
since one bit is always needed for the sign.
Also returns an error if the output type is too small
to hold the requested number of bits.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian, BitCount};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b0001_1111</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="comment">// reading 4 bits with a maximum of 4 will fit into an i8
// so no runtime check needed
</span><span class="macro">assert_eq!</span>(r.read_signed_counted::&lt;<span class="number">4</span>, i8&gt;(BitCount::new::&lt;<span class="number">4</span>&gt;()).unwrap(), <span class="number">1</span>);
<span class="comment">// reading 4 bits with a maximum of 64 might not fit into an i8
// so we need to verify this at runtime
</span><span class="macro">assert_eq!</span>(r.read_signed_counted::&lt;<span class="number">64</span>, i8&gt;(BitCount::new::&lt;<span class="number">4</span>&gt;()).unwrap(), -<span class="number">1</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="tymethod.read_to" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#599-601">Source</a><h4 class="code-header">fn <a href="#tymethod.read_to" class="fn">read_to</a>&lt;V&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;V&gt;<div class="where">where
    V: <a class="trait" href="../trait.Primitive.html" title="trait bitstream_io::Primitive">Primitive</a>,</div></h4></section></summary><div class="docblock"><p>Reads whole value from the stream whose size in bits is equal
to its type’s size.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x56</span>, <span class="number">0x78</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="macro">assert_eq!</span>(r.read_to::&lt;u32&gt;().unwrap(), <span class="number">0x12_34_56_78</span>);</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x56</span>, <span class="number">0x78</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="macro">assert_eq!</span>(r.read_to::&lt;[u8; <span class="number">4</span>]&gt;().unwrap(), [<span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x56</span>, <span class="number">0x78</span>]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="tymethod.read_as_to" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#619-622">Source</a><h4 class="code-header">fn <a href="#tymethod.read_as_to" class="fn">read_as_to</a>&lt;F, V&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;V&gt;<div class="where">where
    F: <a class="trait" href="../trait.Endianness.html" title="trait bitstream_io::Endianness">Endianness</a>,
    V: <a class="trait" href="../trait.Primitive.html" title="trait bitstream_io::Primitive">Primitive</a>,</div></h4></section></summary><div class="docblock"><p>Reads whole value from the stream whose size in bits is equal
to its type’s size in an endianness that may be different
from the stream’s endianness.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian, LittleEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x56</span>, <span class="number">0x78</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="macro">assert_eq!</span>(r.read_as_to::&lt;LittleEndian, u32&gt;().unwrap(), <span class="number">0x78_56_34_12</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="tymethod.byte_aligned" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#856">Source</a><h4 class="code-header">fn <a href="#tymethod.byte_aligned" class="fn">byte_aligned</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if the stream is aligned at a whole byte.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::Read;
<span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data = [<span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data.as_slice(), BigEndian);
<span class="macro">assert_eq!</span>(reader.byte_aligned(), <span class="bool-val">true</span>);
<span class="macro">assert!</span>(reader.skip(<span class="number">1</span>).is_ok());
<span class="macro">assert_eq!</span>(reader.byte_aligned(), <span class="bool-val">false</span>);
<span class="macro">assert!</span>(reader.skip(<span class="number">7</span>).is_ok());
<span class="macro">assert_eq!</span>(reader.byte_aligned(), <span class="bool-val">true</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="tymethod.byte_align" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#870">Source</a><h4 class="code-header">fn <a href="#tymethod.byte_align" class="fn">byte_align</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Throws away all unread bit values until the next whole byte.
Does nothing if the stream is already aligned.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0x00</span>, <span class="number">0xFF</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data, BigEndian);
<span class="macro">assert_eq!</span>(reader.read::&lt;<span class="number">4</span>, u8&gt;().unwrap(), <span class="number">0</span>);
reader.byte_align();
<span class="macro">assert_eq!</span>(reader.read::&lt;<span class="number">8</span>, u8&gt;().unwrap(), <span class="number">0xFF</span>);</code></pre></div></div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.read_bit" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#98-100">Source</a><h4 class="code-header">fn <a href="#method.read_bit" class="fn">read_bit</a>(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Reads a single bit from the stream.
<code>true</code> indicates 1, <code>false</code> indicates 0</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1000_1110</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">false</span>);
<span class="macro">assert!</span>(r.read_bit().is_err());  <span class="comment">// no more bits to read</span></code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, LittleEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1000_1110</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, LittleEndian);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">true</span>);
<span class="macro">assert!</span>(r.read_bit().is_err());  <span class="comment">// no more bits to read</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#138-143">Source</a><h4 class="code-header">fn <a href="#method.read" class="fn">read</a>&lt;const BITS: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, I&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;I&gt;<div class="where">where
    I: <a class="trait" href="../trait.Integer.html" title="trait bitstream_io::Integer">Integer</a>,</div></h4></section></summary><div class="docblock"><p>Reads a signed or unsigned value from the stream with
the given constant number of bits.</p>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.
A compile-time error occurs if the given number of bits
is larger than the output type.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b0001_1111</span>, <span class="number">0b1011_11_00</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="comment">// reading unsigned value is ok
</span><span class="macro">assert_eq!</span>(r.read::&lt;<span class="number">4</span>, u8&gt;().unwrap(), <span class="number">1</span>);
<span class="comment">// reading signed value is also ok
</span><span class="macro">assert_eq!</span>(r.read::&lt;<span class="number">4</span>, i8&gt;().unwrap(), -<span class="number">1</span>);
<span class="comment">// reading an array of bits is ok too
</span><span class="macro">assert_eq!</span>(r.read::&lt;<span class="number">1</span>, [bool; <span class="number">4</span>]&gt;().unwrap(), [<span class="bool-val">true</span>, <span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">true</span>]);
<span class="comment">// reading an array of any Integer type is ok
</span><span class="macro">assert_eq!</span>(r.read::&lt;<span class="number">2</span>, [u8; <span class="number">2</span>]&gt;().unwrap(), [<span class="number">0b11</span>, <span class="number">0b00</span>]);
<span class="comment">// reading more bytes than we have is an error
</span><span class="macro">assert!</span>(r.read::&lt;<span class="number">4</span>, u8&gt;().is_err());</code></pre></div>
<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b0001_1111</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="comment">// reading 9 bits to a u8 is a compile-time error
</span>r.read::&lt;<span class="number">9</span>, u8&gt;();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_var" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#176-181">Source</a><h4 class="code-header">fn <a href="#method.read_var" class="fn">read_var</a>&lt;I&gt;(&amp;mut self, bits: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;I&gt;<div class="where">where
    I: <a class="trait" href="../trait.Integer.html" title="trait bitstream_io::Integer">Integer</a> + <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Reads a signed or unsigned value from the stream with
the given variable number of bits.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.
Also returns an error if the output type is too small
to hold the requested number of bits.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};
<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b0001_1111</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="comment">// reading unsigned value is ok
</span><span class="macro">assert_eq!</span>(r.read_var::&lt;u8&gt;(<span class="number">4</span>).unwrap(), <span class="number">1</span>);
<span class="comment">// reading signed value is also ok
</span><span class="macro">assert_eq!</span>(r.read_var::&lt;i8&gt;(<span class="number">4</span>).unwrap(), -<span class="number">1</span>);
<span class="comment">// reading more bytes than we have is an error
</span><span class="macro">assert!</span>(r.read_var::&lt;u8&gt;(<span class="number">4</span>).is_err());</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};
<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="comment">// reading 9 bits to a u8 is a runtime error
// no matter how much data is left
</span><span class="macro">assert!</span>(r.read_var::&lt;u8&gt;(<span class="number">9</span>).is_err());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_count" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#232-247">Source</a><h4 class="code-header">fn <a href="#method.read_count" class="fn">read_count</a>&lt;const MAX: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../struct.BitCount.html" title="struct bitstream_io::BitCount">BitCount</a>&lt;MAX&gt;&gt;</h4></section></summary><div class="docblock"><p>Given a desired maximum value for a bit count,
reads the necessary bits to fill up to that amount.</p>
<p>For example, if the maximum bit count is 15 - or <code>0b1111</code> -
reads a 4-bit unsigned value from the stream and returns a <a href="../struct.BitCount.html" title="struct bitstream_io::BitCount"><code>BitCount</code></a>
which can be used in subsequent reads.</p>
<p>Note that <code>MAX</code> must be greater than 0, and <code>MAX + 1</code> must be
an exact power of two.</p>
<h5 id="errors-7"><a class="doc-anchor" href="#errors-7">§</a>Errors</h5>
<p>Passes along an I/O error from the underlying stream.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b100_11110</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="kw">let </span>count = r.read::&lt;<span class="number">3</span>, u32&gt;().unwrap();
<span class="macro">assert_eq!</span>(count, <span class="number">4</span>);  <span class="comment">// reads 0b100 - or 4
// may need to verify count is not larger than u8 at runtime
</span><span class="macro">assert_eq!</span>(r.read_var::&lt;u8&gt;(count).unwrap(), <span class="number">0b1111</span>);</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead, BitCount};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b100_11110</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="kw">let </span>count = r.read_count::&lt;<span class="number">0b111</span>&gt;().unwrap();
<span class="macro">assert_eq!</span>(count, BitCount::new::&lt;<span class="number">4</span>&gt;());  <span class="comment">// reads 0b100 - or 4
// maximum size of bit count is known to be 7 at compile-time,
// so no runtime check needed to know 7 bits is not larger than a u8
</span><span class="macro">assert_eq!</span>(r.read_counted::&lt;<span class="number">0b111</span>, u8&gt;(count).unwrap(), <span class="number">0b1111</span>);</code></pre></div>
<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b100_11110</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="comment">// maximum bit count is 6 (0b110), so we need to read 3 bits
// but no idea what to do if a value of 7 (0b111) is read,
// so this does not compile at all
</span><span class="kw">let </span>count = r.read_count::&lt;<span class="number">0b110</span>&gt;();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_counted" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#272-277">Source</a><h4 class="code-header">fn <a href="#method.read_counted" class="fn">read_counted</a>&lt;const MAX: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, I&gt;(&amp;mut self, bits: <a class="struct" href="../struct.BitCount.html" title="struct bitstream_io::BitCount">BitCount</a>&lt;MAX&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;I&gt;<div class="where">where
    I: <a class="trait" href="../trait.Integer.html" title="trait bitstream_io::Integer">Integer</a> + <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Reads a signed or unsigned value from the stream with
the given number of bits.</p>
<h5 id="errors-8"><a class="doc-anchor" href="#errors-8">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.
Also returns an error if the output type is too small
to hold the requested number of bits.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian, BitCount};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1111_0000</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="comment">// reading 4 bits with a maximum of 4 will fit into a u8
// so no runtime check needed
</span><span class="macro">assert_eq!</span>(r.read_counted::&lt;<span class="number">4</span>, u8&gt;(BitCount::new::&lt;<span class="number">4</span>&gt;()).unwrap(), <span class="number">0b1111</span>);
<span class="comment">// reading 4 bits with a maximum of 64 might not fit into a u8
// so we need to verify this at runtime
</span><span class="macro">assert_eq!</span>(r.read_counted::&lt;<span class="number">64</span>, u8&gt;(BitCount::new::&lt;<span class="number">4</span>&gt;()).unwrap(), <span class="number">0b0000</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_unsigned" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#314-319">Source</a><h4 class="code-header">fn <a href="#method.read_unsigned" class="fn">read_unsigned</a>&lt;const BITS: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, U&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;U&gt;<div class="where">where
    U: <a class="trait" href="../trait.UnsignedInteger.html" title="trait bitstream_io::UnsignedInteger">UnsignedInteger</a>,</div></h4></section></summary><div class="docblock"><p>Reads an unsigned value from the stream with
the given constant number of bits.</p>
<h5 id="errors-9"><a class="doc-anchor" href="#errors-9">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.
A compile-time error occurs if the given number of bits
is larger than the output type.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1_01_10111</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data, BigEndian);
<span class="macro">assert_eq!</span>(reader.read_unsigned::&lt;<span class="number">1</span>, u8&gt;().unwrap(), <span class="number">0b1</span>);
<span class="macro">assert_eq!</span>(reader.read_unsigned::&lt;<span class="number">2</span>, u8&gt;().unwrap(), <span class="number">0b01</span>);
<span class="macro">assert_eq!</span>(reader.read_unsigned::&lt;<span class="number">5</span>, u8&gt;().unwrap(), <span class="number">0b10111</span>);</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{LittleEndian, BitReader, BitRead};
<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b10110_11_1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data, LittleEndian);
<span class="macro">assert_eq!</span>(reader.read_unsigned::&lt;<span class="number">1</span>, u8&gt;().unwrap(), <span class="number">0b1</span>);
<span class="macro">assert_eq!</span>(reader.read_unsigned::&lt;<span class="number">2</span>, u8&gt;().unwrap(), <span class="number">0b11</span>);
<span class="macro">assert_eq!</span>(reader.read_unsigned::&lt;<span class="number">5</span>, u8&gt;().unwrap(), <span class="number">0b10110</span>);</code></pre></div>
<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data, BigEndian);
<span class="comment">// doesn't compile at all
</span>reader.read_unsigned::&lt;<span class="number">9</span>, u8&gt;();  <span class="comment">// can't read  9 bits to u8</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_unsigned_var" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#359-364">Source</a><h4 class="code-header">fn <a href="#method.read_unsigned_var" class="fn">read_unsigned_var</a>&lt;U&gt;(&amp;mut self, bits: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;U&gt;<div class="where">where
    U: <a class="trait" href="../trait.UnsignedInteger.html" title="trait bitstream_io::UnsignedInteger">UnsignedInteger</a>,</div></h4></section></summary><div class="docblock"><p>Reads an unsigned value from the stream with
the given number of bits.</p>
<h5 id="errors-10"><a class="doc-anchor" href="#errors-10">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.
Also returns an error if the output type is too small
to hold the requested number of bits.</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1_01_10111</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data, BigEndian);
<span class="macro">assert_eq!</span>(reader.read_unsigned_var::&lt;u8&gt;(<span class="number">1</span>).unwrap(), <span class="number">0b1</span>);
<span class="macro">assert_eq!</span>(reader.read_unsigned_var::&lt;u8&gt;(<span class="number">2</span>).unwrap(), <span class="number">0b01</span>);
<span class="macro">assert_eq!</span>(reader.read_unsigned_var::&lt;u8&gt;(<span class="number">5</span>).unwrap(), <span class="number">0b10111</span>);</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{LittleEndian, BitReader, BitRead};
<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b10110_11_1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data, LittleEndian);
<span class="macro">assert_eq!</span>(reader.read_unsigned_var::&lt;u8&gt;(<span class="number">1</span>).unwrap(), <span class="number">0b1</span>);
<span class="macro">assert_eq!</span>(reader.read_unsigned_var::&lt;u8&gt;(<span class="number">2</span>).unwrap(), <span class="number">0b11</span>);
<span class="macro">assert_eq!</span>(reader.read_unsigned_var::&lt;u8&gt;(<span class="number">5</span>).unwrap(), <span class="number">0b10110</span>);</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data, BigEndian);
<span class="macro">assert!</span>(reader.read_unsigned_var::&lt;u8&gt;(<span class="number">9</span>).is_err());    <span class="comment">// can't read  9 bits to u8
</span><span class="macro">assert!</span>(reader.read_unsigned_var::&lt;u16&gt;(<span class="number">17</span>).is_err());  <span class="comment">// can't read 17 bits to u16
</span><span class="macro">assert!</span>(reader.read_unsigned_var::&lt;u32&gt;(<span class="number">33</span>).is_err());  <span class="comment">// can't read 33 bits to u32
</span><span class="macro">assert!</span>(reader.read_unsigned_var::&lt;u64&gt;(<span class="number">65</span>).is_err());  <span class="comment">// can't read 65 bits to u64</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_signed" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#432-437">Source</a><h4 class="code-header">fn <a href="#method.read_signed" class="fn">read_signed</a>&lt;const BITS: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, S&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;S&gt;<div class="where">where
    S: <a class="trait" href="../trait.SignedInteger.html" title="trait bitstream_io::SignedInteger">SignedInteger</a>,</div></h4></section></summary><div class="docblock"><p>Reads a twos-complement signed value from the stream with
the given constant number of bits.</p>
<h5 id="errors-11"><a class="doc-anchor" href="#errors-11">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.
A compile-time error occurs if the number of bits is 0,
since one bit is always needed for the sign.
A compile-time error occurs if the given number of bits
is larger than the output type.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};

<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1011_0111</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data, BigEndian);
<span class="macro">assert_eq!</span>(reader.read_signed::&lt;<span class="number">4</span>, i8&gt;().unwrap(), -<span class="number">5</span>);
<span class="macro">assert_eq!</span>(reader.read_signed::&lt;<span class="number">4</span>, i8&gt;().unwrap(), <span class="number">7</span>);
<span class="macro">assert!</span>(reader.read_signed::&lt;<span class="number">4</span>, i8&gt;().is_err());</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{LittleEndian, BitReader, BitRead};

<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1011_0111</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data, LittleEndian);
<span class="macro">assert_eq!</span>(reader.read_signed::&lt;<span class="number">4</span>, i8&gt;().unwrap(), <span class="number">7</span>);
<span class="macro">assert_eq!</span>(reader.read_signed::&lt;<span class="number">4</span>, i8&gt;().unwrap(), -<span class="number">5</span>);
<span class="macro">assert!</span>(reader.read_signed::&lt;<span class="number">4</span>, i8&gt;().is_err());</code></pre></div>
<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{LittleEndian, BitReader, BitRead};

<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data, LittleEndian);
<span class="comment">// reading 9 bits to an i8 is a compile-time error
</span>reader.read_signed::&lt;<span class="number">9</span>, i8&gt;();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_signed_var" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#477-482">Source</a><h4 class="code-header">fn <a href="#method.read_signed_var" class="fn">read_signed_var</a>&lt;S&gt;(&amp;mut self, bits: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;S&gt;<div class="where">where
    S: <a class="trait" href="../trait.SignedInteger.html" title="trait bitstream_io::SignedInteger">SignedInteger</a>,</div></h4></section></summary><div class="docblock"><p>Reads a twos-complement signed value from the stream with
the given number of bits.</p>
<h5 id="errors-12"><a class="doc-anchor" href="#errors-12">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.
Returns an error if the number of bits is 0,
since one bit is always needed for the sign.
Also returns an error if the output type is too small
to hold the requested number of bits.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1011_0111</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data, BigEndian);
<span class="macro">assert_eq!</span>(reader.read_signed_var::&lt;i8&gt;(<span class="number">4</span>).unwrap(), -<span class="number">5</span>);
<span class="macro">assert_eq!</span>(reader.read_signed_var::&lt;i8&gt;(<span class="number">4</span>).unwrap(), <span class="number">7</span>);</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{LittleEndian, BitReader, BitRead};
<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1011_0111</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data, LittleEndian);
<span class="macro">assert_eq!</span>(reader.read_signed_var::&lt;i8&gt;(<span class="number">4</span>).unwrap(), <span class="number">7</span>);
<span class="macro">assert_eq!</span>(reader.read_signed_var::&lt;i8&gt;(<span class="number">4</span>).unwrap(), -<span class="number">5</span>);</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::Read;
<span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(data, BigEndian);
<span class="macro">assert!</span>(r.read_signed_var::&lt;i8&gt;(<span class="number">9</span>).is_err());   <span class="comment">// can't read 9 bits to i8
</span><span class="macro">assert!</span>(r.read_signed_var::&lt;i16&gt;(<span class="number">17</span>).is_err()); <span class="comment">// can't read 17 bits to i16
</span><span class="macro">assert!</span>(r.read_signed_var::&lt;i32&gt;(<span class="number">33</span>).is_err()); <span class="comment">// can't read 33 bits to i32
</span><span class="macro">assert!</span>(r.read_signed_var::&lt;i64&gt;(<span class="number">65</span>).is_err()); <span class="comment">// can't read 65 bits to i64</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_const" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#558-574">Source</a><h4 class="code-header">fn <a href="#method.read_const" class="fn">read_const</a>&lt;const BITS: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, const VALUE: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, E&gt;(
    &amp;mut self,
    err: E,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>, E&gt;<div class="where">where
    E: <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.1/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Reads the given constant value from the stream with the
given number of bits.</p>
<p>Due to current limitations of constant paramters,
this is limited to <code>u32</code> values.</p>
<p>If the constant read from the stream doesn’t match the expected
value, returns the generated error from the closure.</p>
<h5 id="errors-13"><a class="doc-anchor" href="#errors-13">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream,
converted to the mismatch error.  Returns the generated
error if the read value doesn’t match the expected constant.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">enum </span>Error {
    Mismatch,
    Io,
}

<span class="kw">impl </span>From&lt;std::io::Error&gt; <span class="kw">for </span>Error {
    <span class="kw">fn </span>from(_err: std::io::Error) -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>::Io
    }
}

<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1000_1011</span>, <span class="number">0b0000_0001</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(data, BigEndian);
<span class="macro">assert!</span>(r.read_const::&lt;<span class="number">4</span>, <span class="number">0b1000</span>, <span class="kw">_</span>&gt;(Error::Mismatch).is_ok());
<span class="macro">assert!</span>(r.read_const::&lt;<span class="number">4</span>, <span class="number">0b1011</span>, <span class="kw">_</span>&gt;(Error::Mismatch).is_ok());
<span class="comment">// 0b1000 doesn't match 0b0000
</span><span class="macro">assert!</span>(<span class="macro">matches!</span>(r.read_const::&lt;<span class="number">4</span>, <span class="number">0b1000</span>, <span class="kw">_</span>&gt;(Error::Mismatch), <span class="prelude-val">Err</span>(Error::Mismatch)));
<span class="comment">// 0b1011 doesn't match 0b0001
</span><span class="macro">assert!</span>(<span class="macro">matches!</span>(r.read_const::&lt;<span class="number">4</span>, <span class="number">0b1011</span>, <span class="kw">_</span>&gt;(Error::Mismatch), <span class="prelude-val">Err</span>(Error::Mismatch)));
<span class="comment">// run out of bits to check
</span><span class="macro">assert!</span>(<span class="macro">matches!</span>(r.read_const::&lt;<span class="number">4</span>, <span class="number">0b0000</span>, <span class="kw">_</span>&gt;(Error::Mismatch), <span class="prelude-val">Err</span>(Error::Io)));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.skip" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#649-651">Source</a><h4 class="code-header">fn <a href="#method.skip" class="fn">skip</a>(&amp;mut self, bits: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Skips the given number of bits in the stream.
Since this method does not need an accumulator,
it may be slightly faster than reading to an empty variable.
In addition, since there is no accumulator,
there is no upper limit on the number of bits
which may be skipped.
These bits are still read from the stream, however,
and are never skipped via a <code>seek</code> method.</p>
<h5 id="errors-14"><a class="doc-anchor" href="#errors-14">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1_00000_10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">true</span>);
<span class="macro">assert!</span>(r.skip(<span class="number">5</span>).is_ok());
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(r.read_bit().unwrap(), <span class="bool-val">false</span>);
<span class="macro">assert!</span>(r.read_bit().is_err());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_bytes" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#674-679">Source</a><h4 class="code-header">fn <a href="#method.read_bytes" class="fn">read_bytes</a>(&amp;mut self, buf: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>]) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Completely fills the given buffer with whole bytes.
If the stream is already byte-aligned, it will map
to a faster <code>read_exact</code> call.  Otherwise it will read
bytes individually in 8-bit increments.</p>
<h5 id="errors-15"><a class="doc-anchor" href="#errors-15">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0</span>; <span class="number">3</span>];
<span class="macro">assert_eq!</span>(r.read::&lt;<span class="number">8</span>, u8&gt;().unwrap(), <span class="number">0x00</span>);
<span class="macro">assert!</span>(r.read_bytes(<span class="kw-2">&amp;mut </span>buf).is_ok());
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>buf, <span class="kw-2">&amp;</span>[<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>]);
<span class="macro">assert_eq!</span>(r.read::&lt;<span class="number">8</span>, u8&gt;().unwrap(), <span class="number">0x04</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_to_bytes" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#691-693">Source</a><h4 class="code-header">fn <a href="#method.read_to_bytes" class="fn">read_to_bytes</a>&lt;const SIZE: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.usize.html">usize</a>&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.array.html">SIZE</a>]&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.8.0: use read_to() method instead</span></div></span></summary><div class="docblock"><p>Completely fills a whole buffer with bytes and returns it.
If the stream is already byte-aligned, it will map
to a faster <code>read_exact</code> call.  Otherwise it will read
bytes individually in 8-bit increments.</p>
<h5 id="errors-16"><a class="doc-anchor" href="#errors-16">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_to_vec" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#717-719">Source</a><h4 class="code-header">fn <a href="#method.read_to_vec" class="fn">read_to_vec</a>(&amp;mut self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.usize.html">usize</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Completely fills a vector of bytes and returns it.
If the stream is already byte-aligned, it will map
to a faster <code>read_exact</code> call.  Otherwise it will read
bytes individually in 8-bit increments.</p>
<h5 id="errors-17"><a class="doc-anchor" href="#errors-17">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0</span>; <span class="number">3</span>];
<span class="macro">assert_eq!</span>(r.read::&lt;<span class="number">8</span>, u8&gt;().unwrap(), <span class="number">0x00</span>);
<span class="macro">assert_eq!</span>(r.read_to_vec(<span class="number">3</span>).unwrap().as_slice(), <span class="kw-2">&amp;</span>[<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>]);
<span class="macro">assert_eq!</span>(r.read::&lt;<span class="number">8</span>, u8&gt;().unwrap(), <span class="number">0x04</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_unary" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#776-787">Source</a><h4 class="code-header">fn <a href="#method.read_unary" class="fn">read_unary</a>&lt;const STOP_BIT: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>&gt;</h4></section></summary><div class="docblock"><p>Counts the number of bits in the stream until <code>STOP_BIT</code>
and returns the amount read.
<code>STOP_BIT</code> must be 0 or 1.
Because this field is variably-sized and may be large,
its output is always a <code>u32</code> type.</p>
<h5 id="errors-18"><a class="doc-anchor" href="#errors-18">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.
May panic if the number of bits exceeds <code>u32</code>.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b0_10_11111</span>, <span class="number">0b10_000000</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="comment">// read 1 bits until stop bit of 0, big-endian order
</span><span class="macro">assert_eq!</span>(r.read_unary::&lt;<span class="number">0</span>&gt;().unwrap(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(r.read_unary::&lt;<span class="number">0</span>&gt;().unwrap(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(r.read_unary::&lt;<span class="number">0</span>&gt;().unwrap(), <span class="number">6</span>);</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1_01_00000</span>, <span class="number">0b01_000000</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="comment">// read 0 bits until stop bit of 1, big-endian order
</span><span class="macro">assert_eq!</span>(r.read_unary::&lt;<span class="number">1</span>&gt;().unwrap(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(r.read_unary::&lt;<span class="number">1</span>&gt;().unwrap(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(r.read_unary::&lt;<span class="number">1</span>&gt;().unwrap(), <span class="number">6</span>);</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, LittleEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b11111_01_0</span>, <span class="number">0b000000_01</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, LittleEndian);
<span class="comment">// read 1 bits until stop bit of 0, little-endian order
</span><span class="macro">assert_eq!</span>(r.read_unary::&lt;<span class="number">0</span>&gt;().unwrap(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(r.read_unary::&lt;<span class="number">0</span>&gt;().unwrap(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(r.read_unary::&lt;<span class="number">0</span>&gt;().unwrap(), <span class="number">6</span>);</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, LittleEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b00000_10_1</span>, <span class="number">0b111111_10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, LittleEndian);
<span class="comment">// read 0 bits until stop bit of 1, little-endian order
</span><span class="macro">assert_eq!</span>(r.read_unary::&lt;<span class="number">1</span>&gt;().unwrap(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(r.read_unary::&lt;<span class="number">1</span>&gt;().unwrap(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(r.read_unary::&lt;<span class="number">1</span>&gt;().unwrap(), <span class="number">6</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_checked" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#817-822">Source</a><h4 class="code-header">fn <a href="#method.read_checked" class="fn">read_checked</a>&lt;C&gt;(&amp;mut self, count: C::<a class="associatedtype" href="../trait.CheckablePrimitive.html#associatedtype.CountType" title="type bitstream_io::CheckablePrimitive::CountType">CountType</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;C&gt;<div class="where">where
    C: <a class="trait" href="../trait.CheckablePrimitive.html" title="trait bitstream_io::CheckablePrimitive">CheckablePrimitive</a>,</div></h4></section></summary><div class="docblock"><p>Reads to a checked value that is known to fit a given number of bits</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{
    BitRead, BitReader, BigEndian, Checked, CheckedUnsigned, CheckedSigned,
    BitCount, SignedBitCount, BitWrite, BitWriter,
};

<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1001_1111</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(data, BigEndian);

<span class="kw">let </span>bit_count = BitCount::&lt;<span class="number">4</span>&gt;::new::&lt;<span class="number">4</span>&gt;();
<span class="kw">let </span>checked_u8 = r.read_checked::&lt;CheckedUnsigned&lt;<span class="number">4</span>, u8&gt;&gt;(bit_count).unwrap();
<span class="macro">assert_eq!</span>(checked_u8.into_value(), <span class="number">0b1001</span>);

<span class="kw">let </span>bit_count = SignedBitCount::&lt;<span class="number">4</span>&gt;::new::&lt;<span class="number">4</span>&gt;();
<span class="kw">let </span>checked_i8 = r.read_checked::&lt;CheckedSigned&lt;<span class="number">4</span>, i8&gt;&gt;(bit_count).unwrap();
<span class="macro">assert_eq!</span>(checked_i8.into_value(), -<span class="number">1</span>);

<span class="comment">// note that checked values already know their bit count
// so none is required when writing them to a stream
</span><span class="kw">let </span><span class="kw-2">mut </span>w = BitWriter::endian(<span class="macro">vec!</span>[], BigEndian);
w.write_checked(checked_u8).unwrap();
w.write_checked(checked_i8).unwrap();
<span class="macro">assert_eq!</span>(w.into_writer().as_slice(), data);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.parse" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#825-827">Source</a><h4 class="code-header">fn <a href="#method.parse" class="fn">parse</a>&lt;F: <a class="trait" href="trait.FromBitStream.html" title="trait bitstream_io::read::FromBitStream">FromBitStream</a>&gt;(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, F::<a class="associatedtype" href="trait.FromBitStream.html#associatedtype.Error" title="type bitstream_io::read::FromBitStream::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses and returns complex type</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_with" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#830-835">Source</a><h4 class="code-header">fn <a href="#method.parse_with" class="fn">parse_with</a>&lt;'a, F: <a class="trait" href="trait.FromBitStreamWith.html" title="trait bitstream_io::read::FromBitStreamWith">FromBitStreamWith</a>&lt;'a&gt;&gt;(
    &amp;mut self,
    context: &amp;F::<a class="associatedtype" href="trait.FromBitStreamWith.html#associatedtype.Context" title="type bitstream_io::read::FromBitStreamWith::Context">Context</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, F::<a class="associatedtype" href="trait.FromBitStreamWith.html#associatedtype.Error" title="type bitstream_io::read::FromBitStreamWith::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses and returns complex type with context</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_using" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#838-840">Source</a><h4 class="code-header">fn <a href="#method.parse_using" class="fn">parse_using</a>&lt;F: <a class="trait" href="trait.FromBitStreamUsing.html" title="trait bitstream_io::read::FromBitStreamUsing">FromBitStreamUsing</a>&gt;(
    &amp;mut self,
    context: F::<a class="associatedtype" href="trait.FromBitStreamUsing.html#associatedtype.Context" title="type bitstream_io::read::FromBitStreamUsing::Context">Context</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, F::<a class="associatedtype" href="trait.FromBitStreamUsing.html#associatedtype.Error" title="type bitstream_io::read::FromBitStreamUsing::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses and returns complex type with owned context</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_huffman" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#898-903">Source</a><h4 class="code-header">fn <a href="#method.read_huffman" class="fn">read_huffman</a>&lt;T&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;T::<a class="associatedtype" href="../huffman/trait.FromBits.html#associatedtype.Symbol" title="type bitstream_io::huffman::FromBits::Symbol">Symbol</a>&gt;<div class="where">where
    T: <a class="trait" href="../huffman/trait.FromBits.html" title="trait bitstream_io::huffman::FromBits">FromBits</a>,</div></h4></section></summary><div class="docblock"><p>Given a compiled Huffman tree, reads bits from the stream
until the next symbol is encountered.</p>
<h5 id="errors-19"><a class="doc-anchor" href="#errors-19">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian, define_huffman_tree, huffman::FromBits};

<span class="macro">define_huffman_tree!</span>(TreeName : char = [<span class="string">'a'</span>, [<span class="string">'b'</span>, [<span class="string">'c'</span>, <span class="string">'d'</span>]]]);
<span class="comment">// 'a' is 0
// 'b' is 1 -&gt; 0
// 'c' is 1 -&gt; 1 -&gt; 0
// 'd' is 1 -&gt; 1 -&gt; 1

</span><span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b0_10_110_11</span>, <span class="number">0b1_0000000</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(data, BigEndian);
<span class="macro">assert_eq!</span>(r.read_huffman::&lt;TreeName&gt;().unwrap(), <span class="string">'a'</span>);
<span class="macro">assert_eq!</span>(r.read_huffman::&lt;TreeName&gt;().unwrap(), <span class="string">'b'</span>);
<span class="macro">assert_eq!</span>(r.read_huffman::&lt;TreeName&gt;().unwrap(), <span class="string">'c'</span>);
<span class="macro">assert_eq!</span>(r.read_huffman::&lt;TreeName&gt;().unwrap(), <span class="string">'d'</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_unsigned_vbr" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#936-962">Source</a><h4 class="code-header">fn <a href="#method.read_unsigned_vbr" class="fn">read_unsigned_vbr</a>&lt;const FIELD_SIZE: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, U: <a class="trait" href="../trait.UnsignedInteger.html" title="trait bitstream_io::UnsignedInteger">UnsignedInteger</a>&gt;(
    &amp;mut self,
) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;U&gt;</h4></section></summary><div class="docblock"><p>Reads a number using a variable using a variable width integer.
This optimises the case when the number is small.</p>
<p>The integer is mapped to an unsigned value using zigzag encoding.
For an integer X:</p>
<ul>
<li>if X &gt;= 0 -&gt; 2X</li>
<li>else -&gt; -2X + 1</li>
</ul>
<h5 id="errors-20"><a class="doc-anchor" href="#errors-20">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.
Returns an error if the data read would overflow the size of the result</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b0111_1100</span>, <span class="number">0b1100_0001</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="macro">assert_eq!</span>(r.read_unsigned_vbr::&lt;<span class="number">4</span>, u32&gt;().unwrap(), <span class="number">7</span>);
<span class="macro">assert_eq!</span>(r.read_unsigned_vbr::&lt;<span class="number">4</span>, u32&gt;().unwrap(), <span class="number">100</span>);</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b1111_1111</span>, <span class="number">0b0011_1000</span>, <span class="number">0b1000_0100</span>, <span class="number">0b1000_1000</span>, <span class="number">0b1000_0000</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="macro">assert_eq!</span>(r.read_unsigned_vbr::&lt;<span class="number">4</span>, u8&gt;().unwrap(), <span class="number">255</span>); <span class="comment">// Tries to read &lt;011&gt;&lt;111&gt;&lt;111&gt;
</span><span class="macro">assert!</span>(r.read_unsigned_vbr::&lt;<span class="number">4</span>, u8&gt;().is_err()); <span class="comment">// Tries to read a value of &lt;100&gt;&lt;000&gt;&lt;000&gt;
</span><span class="macro">assert!</span>(r.read_unsigned_vbr::&lt;<span class="number">4</span>, u8&gt;().is_err()); <span class="comment">// Tries to read a value of &lt;000&gt;&lt;000&gt;&lt;000&gt;&lt;000&gt;</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_signed_vbr" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#986-994">Source</a><h4 class="code-header">fn <a href="#method.read_signed_vbr" class="fn">read_signed_vbr</a>&lt;const FIELD_SIZE: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, I: <a class="trait" href="../trait.SignedInteger.html" title="trait bitstream_io::SignedInteger">SignedInteger</a>&gt;(
    &amp;mut self,
) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;I&gt;</h4></section></summary><div class="docblock"><p>Reads a number using a variable using a variable width integer.
This optimises the case when the number is small.</p>
<p>The integer is mapped to an unsigned value using zigzag encoding.
For an integer X:</p>
<ul>
<li>if X &gt;= 0 -&gt; 2X</li>
<li>else -&gt; -2X + 1</li>
</ul>
<h5 id="errors-21"><a class="doc-anchor" href="#errors-21">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.
Returns an error if the data read would overflow the size of the result</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b0110_1011</span>, <span class="number">0b1100_0001</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="macro">assert_eq!</span>(r.read_signed_vbr::&lt;<span class="number">4</span>, i32&gt;().unwrap(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(r.read_signed_vbr::&lt;<span class="number">4</span>, i32&gt;().unwrap(), -<span class="number">50</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.read_vbr" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1013-1015">Source</a><h4 class="code-header">fn <a href="#method.read_vbr" class="fn">read_vbr</a>&lt;const FIELD_SIZE: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, I: <a class="trait" href="../trait.VBRInteger.html" title="trait bitstream_io::VBRInteger">VBRInteger</a>&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;I&gt;</h4></section></summary><div class="docblock"><p>Reads a signed or unsigned variable width integer from the stream.</p>
<h5 id="errors-22"><a class="doc-anchor" href="#errors-22">§</a>Errors</h5>
<p>Passes along any I/O error from the underlying stream.
Returns an error if the data read would overflow the size of the result</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">let </span>bytes: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0b0110_1011</span>, <span class="number">0b1100_0001</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(bytes, BigEndian);
<span class="macro">assert_eq!</span>(r.read_vbr::&lt;<span class="number">4</span>, u32&gt;().unwrap(), <span class="number">6</span>);
<span class="macro">assert_eq!</span>(r.read_vbr::&lt;<span class="number">4</span>, i32&gt;().unwrap(), -<span class="number">50</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.by_ref" class="method"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1038-1040">Source</a><h4 class="code-header">fn <a href="#method.by_ref" class="fn">by_ref</a>(&amp;mut self) -&gt; &amp;mut Self</h4></section></summary><div class="docblock"><p>Creates a “by reference” adaptor for this <code>BitRead</code></p>
<p>The returned adapter also implements <code>BitRead</code>
and will borrow the current reader.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitstream_io::{BitReader, BitRead, BigEndian};

<span class="kw">fn </span>parse&lt;R: BitRead&gt;(r: R) {
    <span class="comment">// perform some parsing
</span>}

<span class="kw">let </span>data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>reader = BitReader::endian(data, BigEndian);
<span class="comment">// performing parsing by reference
</span>parse(reader.by_ref());
<span class="comment">// original owned reader still available
</span><span class="macro">assert_eq!</span>(reader.read::&lt;<span class="number">8</span>, u8&gt;().unwrap(), <span class="number">0</span>);</code></pre></div></div></details></div><h2 id="dyn-compatibility" class="section-header">Dyn Compatibility<a href="#dyn-compatibility" class="anchor">§</a></h2><div class="dyn-compatibility-info"><p>This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.91.1/reference/items/traits.html#dyn-compatibility">dyn compatible</a>.</p><p><i>In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.</i></p></div><h2 id="foreign-impls" class="section-header">Implementations on Foreign Types<a href="#foreign-impls" class="anchor">§</a></h2><details class="toggle implementors-toggle"><summary><section id="impl-BitRead-for-%26mut+R" class="impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1043-1197">Source</a><a href="#impl-BitRead-for-%26mut+R" class="anchor">§</a><h3 class="code-header">impl&lt;R: <a class="trait" href="trait.BitRead.html" title="trait bitstream_io::read::BitRead">BitRead</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt; <a class="trait" href="trait.BitRead.html" title="trait bitstream_io::read::BitRead">BitRead</a> for <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.reference.html">&amp;mut R</a></h3></section></summary><div class="impl-items"><section id="method.read_bit-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1045-1047">Source</a><a href="#method.read_bit-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.read_bit" class="fn">read_bit</a>(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.bool.html">bool</a>&gt;</h4></section><section id="method.read-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1050-1055">Source</a><a href="#method.read-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.read" class="fn">read</a>&lt;const BITS: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, I&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;I&gt;<div class="where">where
    I: <a class="trait" href="../trait.Integer.html" title="trait bitstream_io::Integer">Integer</a>,</div></h4></section><section id="method.read_var-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1058-1063">Source</a><a href="#method.read_var-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.read_var" class="fn">read_var</a>&lt;I&gt;(&amp;mut self, bits: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;I&gt;<div class="where">where
    I: <a class="trait" href="../trait.Integer.html" title="trait bitstream_io::Integer">Integer</a> + <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section><section id="method.read_count-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1066-1068">Source</a><a href="#method.read_count-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.read_count" class="fn">read_count</a>&lt;const MAX: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../struct.BitCount.html" title="struct bitstream_io::BitCount">BitCount</a>&lt;MAX&gt;&gt;</h4></section><section id="method.read_counted-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1071-1076">Source</a><a href="#method.read_counted-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.read_counted" class="fn">read_counted</a>&lt;const MAX: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, I&gt;(&amp;mut self, bits: <a class="struct" href="../struct.BitCount.html" title="struct bitstream_io::BitCount">BitCount</a>&lt;MAX&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;I&gt;<div class="where">where
    I: <a class="trait" href="../trait.Integer.html" title="trait bitstream_io::Integer">Integer</a> + <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section><section id="method.read_unsigned-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1079-1084">Source</a><a href="#method.read_unsigned-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.read_unsigned" class="fn">read_unsigned</a>&lt;const BITS: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, U&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;U&gt;<div class="where">where
    U: <a class="trait" href="../trait.UnsignedInteger.html" title="trait bitstream_io::UnsignedInteger">UnsignedInteger</a>,</div></h4></section><section id="method.read_unsigned_var-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1087-1092">Source</a><a href="#method.read_unsigned_var-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.read_unsigned_var" class="fn">read_unsigned_var</a>&lt;U&gt;(&amp;mut self, bits: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;U&gt;<div class="where">where
    U: <a class="trait" href="../trait.UnsignedInteger.html" title="trait bitstream_io::UnsignedInteger">UnsignedInteger</a>,</div></h4></section><section id="method.read_unsigned_counted" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1095-1100">Source</a><a href="#method.read_unsigned_counted" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.read_unsigned_counted" class="fn">read_unsigned_counted</a>&lt;const MAX: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, U&gt;(
    &amp;mut self,
    bits: <a class="struct" href="../struct.BitCount.html" title="struct bitstream_io::BitCount">BitCount</a>&lt;MAX&gt;,
) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;U&gt;<div class="where">where
    U: <a class="trait" href="../trait.UnsignedInteger.html" title="trait bitstream_io::UnsignedInteger">UnsignedInteger</a>,</div></h4></section><section id="method.read_signed-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1103-1108">Source</a><a href="#method.read_signed-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.read_signed" class="fn">read_signed</a>&lt;const BITS: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, S&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;S&gt;<div class="where">where
    S: <a class="trait" href="../trait.SignedInteger.html" title="trait bitstream_io::SignedInteger">SignedInteger</a>,</div></h4></section><section id="method.read_signed_var-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1111-1116">Source</a><a href="#method.read_signed_var-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.read_signed_var" class="fn">read_signed_var</a>&lt;S&gt;(&amp;mut self, bits: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;S&gt;<div class="where">where
    S: <a class="trait" href="../trait.SignedInteger.html" title="trait bitstream_io::SignedInteger">SignedInteger</a>,</div></h4></section><section id="method.read_signed_counted" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1119-1127">Source</a><a href="#method.read_signed_counted" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.read_signed_counted" class="fn">read_signed_counted</a>&lt;const MAX: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>, S&gt;(
    &amp;mut self,
    bits: impl <a class="trait" href="https://doc.rust-lang.org/1.91.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;<a class="struct" href="../struct.SignedBitCount.html" title="struct bitstream_io::SignedBitCount">SignedBitCount</a>&lt;MAX&gt;&gt;,
) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;S&gt;<div class="where">where
    S: <a class="trait" href="../trait.SignedInteger.html" title="trait bitstream_io::SignedInteger">SignedInteger</a>,</div></h4></section><section id="method.read_to" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1130-1135">Source</a><a href="#method.read_to" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.read_to" class="fn">read_to</a>&lt;V&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;V&gt;<div class="where">where
    V: <a class="trait" href="../trait.Primitive.html" title="trait bitstream_io::Primitive">Primitive</a>,</div></h4></section><section id="method.read_as_to" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1138-1144">Source</a><a href="#method.read_as_to" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.read_as_to" class="fn">read_as_to</a>&lt;F, V&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;V&gt;<div class="where">where
    F: <a class="trait" href="../trait.Endianness.html" title="trait bitstream_io::Endianness">Endianness</a>,
    V: <a class="trait" href="../trait.Primitive.html" title="trait bitstream_io::Primitive">Primitive</a>,</div></h4></section><section id="method.skip-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1147-1149">Source</a><a href="#method.skip-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.skip" class="fn">skip</a>(&amp;mut self, bits: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>&gt;</h4></section><section id="method.read_bytes-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1152-1154">Source</a><a href="#method.read_bytes-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.read_bytes" class="fn">read_bytes</a>(&amp;mut self, buf: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>]) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.unit.html">()</a>&gt;</h4></section><section id="method.read_to_vec-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1158-1160">Source</a><a href="#method.read_to_vec-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.read_to_vec" class="fn">read_to_vec</a>(&amp;mut self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.usize.html">usize</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>&gt;&gt;</h4></section><section id="method.read_unary-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1163-1165">Source</a><a href="#method.read_unary-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.read_unary" class="fn">read_unary</a>&lt;const STOP_BIT: <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u8.html">u8</a>&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.u32.html">u32</a>&gt;</h4></section><section id="method.parse-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1168-1170">Source</a><a href="#method.parse-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.parse" class="fn">parse</a>&lt;F: <a class="trait" href="trait.FromBitStream.html" title="trait bitstream_io::read::FromBitStream">FromBitStream</a>&gt;(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, F::<a class="associatedtype" href="trait.FromBitStream.html#associatedtype.Error" title="type bitstream_io::read::FromBitStream::Error">Error</a>&gt;</h4></section><section id="method.parse_with-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1173-1178">Source</a><a href="#method.parse_with-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.parse_with" class="fn">parse_with</a>&lt;'a, F: <a class="trait" href="trait.FromBitStreamWith.html" title="trait bitstream_io::read::FromBitStreamWith">FromBitStreamWith</a>&lt;'a&gt;&gt;(
    &amp;mut self,
    context: &amp;F::<a class="associatedtype" href="trait.FromBitStreamWith.html#associatedtype.Context" title="type bitstream_io::read::FromBitStreamWith::Context">Context</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, F::<a class="associatedtype" href="trait.FromBitStreamWith.html#associatedtype.Error" title="type bitstream_io::read::FromBitStreamWith::Error">Error</a>&gt;</h4></section><section id="method.byte_aligned" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1181-1183">Source</a><a href="#method.byte_aligned" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.byte_aligned" class="fn">byte_aligned</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.1/std/primitive.bool.html">bool</a></h4></section><section id="method.byte_align" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1186-1188">Source</a><a href="#method.byte_align" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.byte_align" class="fn">byte_align</a>(&amp;mut self)</h4></section><section id="method.read_huffman-1" class="method trait-impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1191-1196">Source</a><a href="#method.read_huffman-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.read_huffman" class="fn">read_huffman</a>&lt;T&gt;(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.91.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;T::<a class="associatedtype" href="../huffman/trait.FromBits.html#associatedtype.Symbol" title="type bitstream_io::huffman::FromBits::Symbol">Symbol</a>&gt;<div class="where">where
    T: <a class="trait" href="../huffman/trait.FromBits.html" title="trait bitstream_io::huffman::FromBits">FromBits</a>,</div></h4></section></div></details><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><section id="impl-BitRead-for-BitReader%3CR,+E%3E" class="impl"><a class="src rightside" href="../../src/bitstream_io/read.rs.html#1614-1790">Source</a><a href="#impl-BitRead-for-BitReader%3CR,+E%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R: <a class="trait" href="https://doc.rust-lang.org/1.91.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a>, E: <a class="trait" href="../trait.Endianness.html" title="trait bitstream_io::Endianness">Endianness</a>&gt; <a class="trait" href="trait.BitRead.html" title="trait bitstream_io::read::BitRead">BitRead</a> for <a class="struct" href="struct.BitReader.html" title="struct bitstream_io::read::BitReader">BitReader</a>&lt;R, E&gt;</h3></section></div><script src="../../trait.impl/bitstream_io/read/trait.BitRead.js" async></script></section></div></main></body></html>