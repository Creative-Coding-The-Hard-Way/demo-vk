<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Traits and helpers for bitstream handling functionality"><title>bitstream_io - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bitstream_io" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0 (ded5c06cf 2025-12-08)" data-channel="1.92.0" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate bitstream_io</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../bitstream_io/index.html">bitstream_<wbr>io</a><span class="version">4.9.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#minimum-compiler-version" title="Minimum Compiler Version">Minimum Compiler Version</a></li><li><a href="#changes-from-3xx" title="Changes From 3.X.X">Changes From 3.X.X</a></li><li><a href="#changes-from-2xx" title="Changes From 2.X.X">Changes From 2.X.X</a></li><li><a href="#migrating-from-pre-100" title="Migrating From Pre 1.0.0">Migrating From Pre 1.0.0</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>bitstream_<wbr>io</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/bitstream_io/lib.rs.html#9-3762">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Traits and helpers for bitstream handling functionality</p>
<p>Bitstream readers are for reading signed and unsigned integer
values from a stream whose sizes may not be whole bytes.
Bitstream writers are for writing signed and unsigned integer
values to a stream, also potentially un-aligned at a whole byte.</p>
<p>Both big-endian and little-endian streams are supported.</p>
<p>The only requirement for wrapped reader streams is that they must
implement the <a href="https://doc.rust-lang.org/1.92.0/std/io/trait.Read.html" title="trait std::io::Read"><code>io::Read</code></a> trait, and the only requirement
for writer streams is that they must implement the <a href="https://doc.rust-lang.org/1.92.0/std/io/trait.Write.html" title="trait std::io::Write"><code>io::Write</code></a> trait.</p>
<p>In addition, reader streams do not consume any more bytes
from the underlying reader than necessary, buffering only a
single partial byte as needed.
Writer streams also write out all whole bytes as they are accumulated.</p>
<p>Readers and writers are also designed to work with integer
types of any possible size.
Many of Rust’s built-in integer types are supported by default.</p>
<h2 id="minimum-compiler-version"><a class="doc-anchor" href="#minimum-compiler-version">§</a>Minimum Compiler Version</h2>
<p>Beginning with version 2.4, the minimum compiler version has been
updated to Rust 1.79.</p>
<p>The issue is that reading an excessive number of
bits to a type which is too small to hold them,
or writing an excessive number of bits from too small of a type,
are always errors:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::{Read, Cursor};
<span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data = [<span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(Cursor::new(<span class="kw-2">&amp;</span>data), BigEndian);
<span class="kw">let </span>x: <span class="prelude-ty">Result</span>&lt;u32, <span class="kw">_</span>&gt; = r.read_var(<span class="number">64</span>);  <span class="comment">// reading 64 bits to u32 always fails at runtime
</span><span class="macro">assert!</span>(x.is_err());</code></pre></div>
<p>but those errors will not be caught until the program runs,
which is less than ideal for the common case in which
the number of bits is already known at compile-time.</p>
<p>But starting with Rust 1.79, we can now have read and write methods
which take a constant number of bits and can validate the number of bits
are small enough for the type being read/written at compile-time:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::{Read, Cursor};
<span class="kw">use </span>bitstream_io::{BigEndian, BitReader, BitRead};
<span class="kw">let </span>data = [<span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = BitReader::endian(Cursor::new(<span class="kw-2">&amp;</span>data), BigEndian);
<span class="kw">let </span>x: <span class="prelude-ty">Result</span>&lt;u32, <span class="kw">_</span>&gt; = r.read::&lt;<span class="number">64</span>, <span class="kw">_</span>&gt;();  <span class="comment">// doesn't compile at all</span></code></pre></div>
<p>Since catching potential bugs at compile-time is preferable
to encountering errors at runtime, this will hopefully be
an improvement in the long run.</p>
<h2 id="changes-from-3xx"><a class="doc-anchor" href="#changes-from-3xx">§</a>Changes From 3.X.X</h2>
<p>Version 4.0.0 features significant optimizations to the <a href="write/struct.BitRecorder.html" title="struct bitstream_io::write::BitRecorder"><code>BitRecorder</code></a>
and deprecates the <a href="write/struct.BitCounter.html" title="struct bitstream_io::write::BitCounter"><code>BitCounter</code></a> in favor of <a href="write/struct.BitsWritten.html" title="struct bitstream_io::write::BitsWritten"><code>BitsWritten</code></a>,
which no longer requires specifying an endianness.</p>
<p>In addition, the <a href="read/trait.BitRead.html#method.read_bytes" title="method bitstream_io::read::BitRead::read_bytes"><code>BitRead::read_bytes</code></a> and <a href="write/trait.BitWrite.html#method.write_bytes" title="method bitstream_io::write::BitWrite::write_bytes"><code>BitWrite::write_bytes</code></a>
methods are significantly optimized in the case of non-aligned
reads and writes.</p>
<p>Finally, the <a href="trait.Endianness.html" title="trait bitstream_io::Endianness"><code>Endianness</code></a> traits have been sealed so as not
to be implemented by other packages.  Given that other endianness
types are extremely rare in file formats and end users should not
have to implement this trait themselves, this should not be a
concern.</p>
<h2 id="changes-from-2xx"><a class="doc-anchor" href="#changes-from-2xx">§</a>Changes From 2.X.X</h2>
<p>Version 3.0.0 has made many breaking changes to the <a href="read/trait.BitRead.html" title="trait bitstream_io::read::BitRead"><code>BitRead</code></a> and
<a href="write/trait.BitWrite.html" title="trait bitstream_io::write::BitWrite"><code>BitWrite</code></a> traits.</p>
<p>The <a href="read/trait.BitRead.html#method.read" title="method bitstream_io::read::BitRead::read"><code>BitRead::read</code></a> method takes a constant number of bits,
and the <a href="read/trait.BitRead.html#method.read_var" title="method bitstream_io::read::BitRead::read_var"><code>BitRead::read_var</code></a> method takes a variable number of bits
(reversing the older <a href="read/trait.BitRead2.html#method.read_in" title="method bitstream_io::read::BitRead2::read_in"><code>BitRead2::read_in</code></a> and <a href="read/trait.BitRead2.html#tymethod.read" title="method bitstream_io::read::BitRead2::read"><code>BitRead2::read</code></a>
calling methods to emphasize using the constant-based one,
which can do more validation at compile-time).
A new <a href="read/trait.BitRead2.html" title="trait bitstream_io::read::BitRead2"><code>BitRead2</code></a> trait uses the older calling convention
for compatibility with existing code and is available
for anything implementing <a href="read/trait.BitRead.html" title="trait bitstream_io::read::BitRead"><code>BitRead</code></a>.</p>
<p>In addition, the main reading methods return primitive types which
implement a new <a href="trait.Integer.html" title="trait bitstream_io::Integer"><code>Integer</code></a> trait,
which delegates to <a href="read/trait.BitRead.html#method.read_unsigned" title="method bitstream_io::read::BitRead::read_unsigned"><code>BitRead::read_unsigned</code></a>
or <a href="read/trait.BitRead.html#method.read_signed" title="method bitstream_io::read::BitRead::read_signed"><code>BitRead::read_signed</code></a> depending on whether the output
is an unsigned or signed type.</p>
<p><a href="write/trait.BitWrite.html#method.write" title="method bitstream_io::write::BitWrite::write"><code>BitWrite::write</code></a> and <a href="write/trait.BitWrite.html#method.write_var" title="method bitstream_io::write::BitWrite::write_var"><code>BitWrite::write_var</code></a> work
similarly to the reader’s <code>read</code> methods, taking anything
that implements <a href="trait.Integer.html" title="trait bitstream_io::Integer"><code>Integer</code></a> and writing an unsigned or
signed value to <a href="write/trait.BitWrite.html#method.write_unsigned" title="method bitstream_io::write::BitWrite::write_unsigned"><code>BitWrite::write_unsigned</code></a> or
<a href="write/trait.BitWrite.html#method.write_signed" title="method bitstream_io::write::BitWrite::write_signed"><code>BitWrite::write_signed</code></a> as appropriate.</p>
<p>And as with reading, a <a href="write/trait.BitWrite2.html" title="trait bitstream_io::write::BitWrite2"><code>BitWrite2</code></a> trait is offered
for compatibility.</p>
<p>In addition, the Huffman code handling has been rewritten
to use a small amount of macro magic to write
code to read and write symbols at compile-time.
This is significantly faster than the older version
and can no longer fail to compile at runtime.</p>
<p>Lastly, there’s a new <a href="struct.BitCount.html" title="struct bitstream_io::BitCount"><code>BitCount</code></a> struct which wraps a humble
<code>u32</code> but encodes the maximum possible number of bits
at the type level.
This is intended for file formats which encode the number
of bits to be read in the format itself.
For example, FLAC’s predictor coefficient precision
is a 4 bit value which indicates how large each predictor
coefficient is in bits
(each coefficient might be an <code>i32</code> type).
By keeping track of the maximum value at compile time
(4 bits’ worth, in this case), we can eliminate
any need to check that coefficients aren’t too large
for an <code>i32</code> at runtime.
This is accomplished by using <a href="read/trait.BitRead.html#method.read_count" title="method bitstream_io::read::BitRead::read_count"><code>BitRead::read_count</code></a> to
read a <a href="struct.BitCount.html" title="struct bitstream_io::BitCount"><code>BitCount</code></a> and then reading final values with
that number of bits using <a href="read/trait.BitRead.html#method.read_counted" title="method bitstream_io::read::BitRead::read_counted"><code>BitRead::read_counted</code></a>.</p>
<h2 id="migrating-from-pre-100"><a class="doc-anchor" href="#migrating-from-pre-100">§</a>Migrating From Pre 1.0.0</h2>
<p>There are now <a href="read/trait.BitRead.html" title="trait bitstream_io::read::BitRead"><code>BitRead</code></a> and <a href="write/trait.BitWrite.html" title="trait bitstream_io::write::BitWrite"><code>BitWrite</code></a> traits for bitstream
reading and writing (analogous to the standard library’s
<code>Read</code> and <code>Write</code> traits) which you will also need to import.
The upside to this approach is that library consumers
can now make functions and methods generic over any sort
of bit reader or bit writer, regardless of the underlying
stream byte source or endianness.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.BitRead"><code>pub use read::<a class="trait" href="read/trait.BitRead.html" title="trait bitstream_io::read::BitRead">BitRead</a>;</code></dt><dt id="reexport.BitRead2"><code>pub use read::<a class="trait" href="read/trait.BitRead2.html" title="trait bitstream_io::read::BitRead2">BitRead2</a>;</code></dt><dt id="reexport.BitReader"><code>pub use read::<a class="struct" href="read/struct.BitReader.html" title="struct bitstream_io::read::BitReader">BitReader</a>;</code></dt><dt id="reexport.ByteRead"><code>pub use read::<a class="trait" href="read/trait.ByteRead.html" title="trait bitstream_io::read::ByteRead">ByteRead</a>;</code></dt><dt id="reexport.ByteReader"><code>pub use read::<a class="struct" href="read/struct.ByteReader.html" title="struct bitstream_io::read::ByteReader">ByteReader</a>;</code></dt><dt id="reexport.FromBitStream"><code>pub use read::<a class="trait" href="read/trait.FromBitStream.html" title="trait bitstream_io::read::FromBitStream">FromBitStream</a>;</code></dt><dt id="reexport.FromBitStreamUsing"><code>pub use read::<a class="trait" href="read/trait.FromBitStreamUsing.html" title="trait bitstream_io::read::FromBitStreamUsing">FromBitStreamUsing</a>;</code></dt><dt id="reexport.FromBitStreamWith"><code>pub use read::<a class="trait" href="read/trait.FromBitStreamWith.html" title="trait bitstream_io::read::FromBitStreamWith">FromBitStreamWith</a>;</code></dt><dt id="reexport.FromByteStream"><code>pub use read::<a class="trait" href="read/trait.FromByteStream.html" title="trait bitstream_io::read::FromByteStream">FromByteStream</a>;</code></dt><dt id="reexport.FromByteStreamUsing"><code>pub use read::<a class="trait" href="read/trait.FromByteStreamUsing.html" title="trait bitstream_io::read::FromByteStreamUsing">FromByteStreamUsing</a>;</code></dt><dt id="reexport.FromByteStreamWith"><code>pub use read::<a class="trait" href="read/trait.FromByteStreamWith.html" title="trait bitstream_io::read::FromByteStreamWith">FromByteStreamWith</a>;</code></dt><dt id="reexport.BitRecorder"><code>pub use write::<a class="struct" href="write/struct.BitRecorder.html" title="struct bitstream_io::write::BitRecorder">BitRecorder</a>;</code></dt><dt id="reexport.BitWrite"><code>pub use write::<a class="trait" href="write/trait.BitWrite.html" title="trait bitstream_io::write::BitWrite">BitWrite</a>;</code></dt><dt id="reexport.BitWrite2"><code>pub use write::<a class="trait" href="write/trait.BitWrite2.html" title="trait bitstream_io::write::BitWrite2">BitWrite2</a>;</code></dt><dt id="reexport.BitWriter"><code>pub use write::<a class="struct" href="write/struct.BitWriter.html" title="struct bitstream_io::write::BitWriter">BitWriter</a>;</code></dt><dt id="reexport.BitsWritten"><code>pub use write::<a class="struct" href="write/struct.BitsWritten.html" title="struct bitstream_io::write::BitsWritten">BitsWritten</a>;</code></dt><dt id="reexport.ByteWrite"><code>pub use write::<a class="trait" href="write/trait.ByteWrite.html" title="trait bitstream_io::write::ByteWrite">ByteWrite</a>;</code></dt><dt id="reexport.ByteWriter"><code>pub use write::<a class="struct" href="write/struct.ByteWriter.html" title="struct bitstream_io::write::ByteWriter">ByteWriter</a>;</code></dt><dt id="reexport.ToBitStream"><code>pub use write::<a class="trait" href="write/trait.ToBitStream.html" title="trait bitstream_io::write::ToBitStream">ToBitStream</a>;</code></dt><dt id="reexport.ToBitStreamUsing"><code>pub use write::<a class="trait" href="write/trait.ToBitStreamUsing.html" title="trait bitstream_io::write::ToBitStreamUsing">ToBitStreamUsing</a>;</code></dt><dt id="reexport.ToBitStreamWith"><code>pub use write::<a class="trait" href="write/trait.ToBitStreamWith.html" title="trait bitstream_io::write::ToBitStreamWith">ToBitStreamWith</a>;</code></dt><dt id="reexport.ToByteStream"><code>pub use write::<a class="trait" href="write/trait.ToByteStream.html" title="trait bitstream_io::write::ToByteStream">ToByteStream</a>;</code></dt><dt id="reexport.ToByteStreamUsing"><code>pub use write::<a class="trait" href="write/trait.ToByteStreamUsing.html" title="trait bitstream_io::write::ToByteStreamUsing">ToByteStreamUsing</a>;</code></dt><dt id="reexport.ToByteStreamWith"><code>pub use write::<a class="trait" href="write/trait.ToByteStreamWith.html" title="trait bitstream_io::write::ToByteStreamWith">ToByteStreamWith</a>;</code></dt><dt id="reexport.BitCounter"><code>pub use write::<a class="struct" href="write/struct.BitCounter.html" title="struct bitstream_io::write::BitCounter">BitCounter</a>;</code><wbr><span class="stab deprecated" title="">Deprecated</span></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="huffman/index.html" title="mod bitstream_io::huffman">huffman</a></dt><dd>Traits and implementations for reading or writing Huffman codes
from or to a stream.</dd><dt><a class="mod" href="read/index.html" title="mod bitstream_io::read">read</a></dt><dd>Traits and implementations for reading bits from a stream.</dd><dt><a class="mod" href="write/index.html" title="mod bitstream_io::write">write</a></dt><dd>Traits and implementations for writing bits to a stream.</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.compile_read_tree_nodes.html" title="macro bitstream_io::compile_read_tree_nodes">compile_<wbr>read_<wbr>tree_<wbr>nodes</a></dt><dd>A helper macro for compiling individual Huffman tree nodes</dd><dt><a class="macro" href="macro.compile_write_tree_nodes.html" title="macro bitstream_io::compile_write_tree_nodes">compile_<wbr>write_<wbr>tree_<wbr>nodes</a></dt><dd>A helper macro for compiling individual Huffman tree nodes</dd><dt><a class="macro" href="macro.define_huffman_tree.html" title="macro bitstream_io::define_huffman_tree">define_<wbr>huffman_<wbr>tree</a></dt><dd>Defines a new Huffman tree for reading and writing</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BigEndian.html" title="struct bitstream_io::BigEndian">BigEndian</a></dt><dd>Big-endian, or most significant bits first</dd><dt><a class="struct" href="struct.BitCount.html" title="struct bitstream_io::BitCount">BitCount</a></dt><dd>A number of bits to be consumed or written, with a known maximum</dd><dt><a class="struct" href="struct.Checked.html" title="struct bitstream_io::Checked">Checked</a></dt><dd>A type for eliminating redundant validation when writing</dd><dt><a class="struct" href="struct.FixedBitCount.html" title="struct bitstream_io::FixedBitCount">Fixed<wbr>BitCount</a></dt><dd>A fixed number of bits to be consumed or written</dd><dt><a class="struct" href="struct.FixedSignedBitCount.html" title="struct bitstream_io::FixedSignedBitCount">Fixed<wbr>Signed<wbr>BitCount</a></dt><dd>A fixed number of bits to be consumed or written</dd><dt><a class="struct" href="struct.LittleEndian.html" title="struct bitstream_io::LittleEndian">Little<wbr>Endian</a></dt><dd>Little-endian, or least significant bits first</dd><dt><a class="struct" href="struct.SignedBitCount.html" title="struct bitstream_io::SignedBitCount">Signed<wbr>BitCount</a></dt><dd>A number of bits to be read or written for signed integers, with a known maximum</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.CheckedError.html" title="enum bitstream_io::CheckedError">Checked<wbr>Error</a></dt><dd>An error when converting a value to a <a href="struct.Checked.html" title="struct bitstream_io::Checked"><code>Checked</code></a> struct</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Checkable.html" title="trait bitstream_io::Checkable">Checkable</a></dt><dd>A trait for writable types whose values can be validated</dd><dt><a class="trait" href="trait.CheckablePrimitive.html" title="trait bitstream_io::CheckablePrimitive">Checkable<wbr>Primitive</a></dt><dd>A trait for readable types whose bit counts can be saved</dd><dt><a class="trait" href="trait.Endianness.html" title="trait bitstream_io::Endianness">Endianness</a></dt><dd>A stream’s endianness, or byte order, for determining
how bits should be read.</dd><dt><a class="trait" href="trait.Integer.html" title="trait bitstream_io::Integer">Integer</a></dt><dd>This trait is for integer types which can be read or written
to a bit stream as a partial amount of bits.</dd><dt><a class="trait" href="trait.Numeric.html" title="trait bitstream_io::Numeric">Numeric</a></dt><dd>This trait extends many common integer types (both unsigned and signed)
with a few trivial methods so that they can be used
with the bitstream handling traits.</dd><dt><a class="trait" href="trait.Primitive.html" title="trait bitstream_io::Primitive">Primitive</a></dt><dd>A trait intended for simple fixed-length primitives (such as ints and floats)
which allows them to be read and written to streams of
different endiannesses verbatim.</dd><dt><a class="trait" href="trait.SignedInteger.html" title="trait bitstream_io::SignedInteger">Signed<wbr>Integer</a></dt><dd>This trait extends many common signed integer types
so that they can be used with the bitstream handling traits.</dd><dt><a class="trait" href="trait.UnsignedInteger.html" title="trait bitstream_io::UnsignedInteger">Unsigned<wbr>Integer</a></dt><dd>This trait extends many common unsigned integer types
so that they can be used with the bitstream handling traits.</dd><dt><a class="trait" href="trait.VBRInteger.html" title="trait bitstream_io::VBRInteger">VBRInteger</a></dt><dd>This trait is for integer types which can be read or written
to a bit stream as variable-width integers.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.BE.html" title="type bitstream_io::BE">BE</a></dt><dd>Big-endian, or most significant bits first</dd><dt><a class="type" href="type.CheckedSigned.html" title="type bitstream_io::CheckedSigned">Checked<wbr>Signed</a></dt><dd>A signed type with a verified value</dd><dt><a class="type" href="type.CheckedSignedFixed.html" title="type bitstream_io::CheckedSignedFixed">Checked<wbr>Signed<wbr>Fixed</a></dt><dd>A signed type with a verified value for a fixed number of bits</dd><dt><a class="type" href="type.CheckedUnsigned.html" title="type bitstream_io::CheckedUnsigned">Checked<wbr>Unsigned</a></dt><dd>An unsigned type with a verified value</dd><dt><a class="type" href="type.CheckedUnsignedFixed.html" title="type bitstream_io::CheckedUnsignedFixed">Checked<wbr>Unsigned<wbr>Fixed</a></dt><dd>An unsigned type with a verified value for a fixed number of bits</dd><dt><a class="type" href="type.LE.html" title="type bitstream_io::LE">LE</a></dt><dd>Little-endian, or least significant bits first</dd></dl></section></div></main></body></html>